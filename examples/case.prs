(length 1 - @)   'bring-bottom define
(bring-bottom !) 'apply-bottom define

''case 'case define

; setup the stack by copying everything before the case forward 
(bring-bottom dpl 'case_bfb eqv? (drop) (case_build-buffer) if !) 'case_build-buffer define 

(
	; as we will see we need the stack to be:
	; ... case_bfb C1 E1 ... CN EN case_bft
	; We bring the bottom item
	; if it marks the end of the case we drop it and we are done
	; if its a condtion we apply it
	; if it yields true we apply its corrisponding expression
	; else we drop both of them and continue

	bring-bottom dpl 'case_bft eqv? 
	(drop) 	
	(   ! ; apply the condition

		(apply-bottom)
		(bring-bottom drop case_run) if !
	) if !
) 'case_run define 

(bring-bottom dpl 'case_bft eqv? (drop) (drop case_clear) if !) 'case_clear define 

( 
	; give a distinct marker so it want interefere with nested cases
	'case_bfb case find 1 - setat
	'case_bft
	
	; bfb - buffer bottom, bft - buffer top
	; by now the stack should be:
	; ... case_bfb C1 E1 ... CN EN case_bft

	case_build-buffer
	
	; now the stack is:
	; C1 E1 ... CN EN case_bft ...
	; So its dead simple to handle see case_run
	
	case_run
	
	; whipe the residue if needed
	'case_bft find 0 < () (case_clear) if !

) 'end-case define

''else 'else define

3
case
   (dpl 3 <)   ('A outln)
   (dpl 3 =)   (case (5 3 <) ('C outln) (else) ('D outln) end-case)
   (else)      ('B outln)
end-case
?stk
