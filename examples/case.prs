(length 1 - @)   'bring-bottom define
(bring-bottom !) 'apply-bottom define

''case 'case define

; setup the stack by copying overthing before the case forward 
(bring-bottom dpl 'case_bfb eqv? (drop) (case_build-buffer) if !) 'case_build-buffer define 

; run the case structure 
(
	dpl 'case_bft eqv? 
	(drop) ; reached bottom drop case_bft 
		
	; bring the bottom condition 
	; if its true: bring bottom expression remove the unneeded conds and exprs and run expr 
	; else: remove the bottom expression and repeat 
	(apply-bottom (bring-bottom case_clear !) 
	(bring-bottom drop case_run) if !) if !
) 'case_run define 

; clear terminated case
(bring-bottom 'case_bft dpl eqv? (drop) (drop case_clear) if !) 'case_clear define 

( 
	'case_bfb case find 1 - setat ; change the marking of the most recent case to case_bfb or case buffer bottom 
	'case_bft ; insert a case_bft label or case buffer top to mark the end of the structure 

	case_build-buffer ; by now get [c1 e1 ... cn en case_bft stack-tail ...] 

	case_run ; run the case structure 

) 'end-case define

1 'else define

1 2 3
case
   (dpl 3 <)   ('A outln)
   (dpl 3 =)   (case (5 3 <) ('C outln) (else) ('D outln) end-case)
   (dpl else)    ('B outln)
end-case

